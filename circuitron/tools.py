"""
    )
Tools for the Circuitron agents.
Contains calculation tools and other utilities that agents can use.
"""

from agents import function_tool
from agents.mcp import MCPServerSse

__all__ = [
    "MCPServerSse",
    "create_mcp_documentation_server",
    "create_mcp_validation_server",
    "run_erc_tool",
    "search_kicad_libraries",
    "search_kicad_footprints",
    "extract_pin_details",
]
import asyncio
import os
import subprocess
import textwrap
import json
from .models import CalcResult
from .config import settings
from .docker_session import DockerSession

__all__ = [
    "MCPServerSse",
    "execute_calculation",
    "search_kicad_libraries",
    "search_kicad_footprints",
    "extract_pin_details",
    "create_mcp_documentation_server",
    "create_mcp_validation_server",
    "run_erc",
    "run_erc_tool",
]


container_name = f"circuitron-kicad-{os.getpid()}"
kicad_session = DockerSession(settings.kicad_image, container_name)


@function_tool
async def execute_calculation(
    calculation_id: str,
    description: str,
    code: str,
) -> CalcResult:
    """
    Execute pure-Python maths code *generated by the LLM* in an isolated Docker container.

    Args:
        calculation_id: Correlates this request to its tool response.
        description: What this calculation is intended to compute.
        code: Python source (generated by the LLM) that prints the final value.
    Returns:
        CalcResult with stdout, stderr, and success flag.
    """
    safe_code = textwrap.dedent(code)
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "128m",
        "--pids-limit",
        "64",
        settings.calculation_image,
        "python",
        "-c",
        safe_code,
    ]
    try:
        proc = await asyncio.to_thread(
            subprocess.run,
            docker_cmd,
            capture_output=True,
            text=True,
            timeout=15,
            check=True,
        )
    except subprocess.TimeoutExpired as exc:
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))
    except subprocess.CalledProcessError as exc:
        return CalcResult(
            calculation_id=calculation_id,
            success=False,
            stdout=exc.stdout.strip(),
            stderr=exc.stderr.strip(),
        )
    except Exception as exc:  # pragma: no cover - unexpected errors
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))

    return CalcResult(
        calculation_id=calculation_id,
        success=True,
        stdout=proc.stdout.strip(),
        stderr=proc.stderr.strip(),
    )


@function_tool
async def search_kicad_libraries(query: str, max_results: int = 50) -> str:
    """Search KiCad libraries using ``skidl.search``.

    Args:
        query: Search string passed to ``skidl.search``.
        max_results: Maximum number of results to return (default: 50).

    Returns:
        JSON string representing a list of matching parts, ordered by relevance.
    """
    script = textwrap.dedent(
        f"""
import json, io, contextlib
from skidl import *
set_default_tool(KICAD5)
max_results = {max_results}
buf = io.StringIO()
try:
    with contextlib.redirect_stdout(buf):
        search({query!r})
except Exception as exc:
    print(json.dumps({{"error": str(exc)}}))
    raise SystemExit()
text = buf.getvalue().splitlines()
results = []
for line in text:
    line = line.strip()
    if '.lib:' in line and '(' in line and ')' in line:
        try:
            lib_part = line.split('.lib:', 1)
            library = lib_part[0].strip()
            part_info = lib_part[1].strip()
            if '(' in part_info:
                name_desc = part_info.split('(', 1)
                name = name_desc[0].strip()
                description = name_desc[1].rstrip(')') if len(name_desc) > 1 else ''
                results.append({{"name": name, "library": library, "description": description, "footprint": None}})
        except Exception:
            continue

# Apply smart filtering and limiting
filtered_results = []
basic_components = []
specific_components = []

# Separate basic components from complex ones
for result in results:
    name = result["name"].lower()
    desc = result["description"].lower() if result["description"] else ""
    
    # Identify basic passive components that should be prioritized
    if (name in ["r", "c", "l", "r_small", "c_small", "l_small"] or 
        (len(name) <= 3 and any(word in desc for word in ["resistor", "capacitor", "inductor"]) and 
         not any(word in desc for word in ["network", "array", "pack", "dual", "quad"]))):
        basic_components.append(result)
    else:
        specific_components.append(result)

# Prioritize: basic components first, then specific ones, limit total
filtered_results = basic_components[:10] + specific_components[:max_results-len(basic_components)]
filtered_results = filtered_results[:max_results]

print(json.dumps(filtered_results))
"""
    )
    try:
        proc = await asyncio.to_thread(kicad_session.exec_python, script, timeout=120)
    except subprocess.TimeoutExpired as exc:
        return json.dumps({"error": "search timeout", "details": str(exc)})
    except subprocess.CalledProcessError as exc:
        error_details = {
            "subprocess_stderr": exc.stderr.strip(),
            "subprocess_stdout": exc.stdout.strip() if hasattr(exc, "stdout") else "",
            "return_code": exc.returncode,
        }
        return json.dumps({"error": "subprocess failed", "details": error_details})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps(
            {
                "error": "unexpected error",
                "details": str(exc),
                "type": type(exc).__name__,
            }
        )
    return proc.stdout.strip()


@function_tool
async def search_kicad_footprints(query: str, max_results: int = 30) -> str:
    """Search KiCad footprint libraries using ``skidl.search_footprints``.

    Args:
        query: Search string passed to ``skidl.search_footprints``.
        max_results: Maximum number of results to return (default: 30).

    Returns:
        JSON string representing a list of matching footprints.
    """
    script = textwrap.dedent(
        f"""
import json, io, contextlib
from skidl import *
set_default_tool(KICAD5)
max_results = {max_results}
buf = io.StringIO()
try:
    with contextlib.redirect_stdout(buf):
        search_footprints({query!r})
except Exception as exc:
    print(json.dumps({{"error": str(exc)}}))
    raise SystemExit()
text = buf.getvalue().splitlines()
results = []
for line in text:
    line = line.strip()
    if '.pretty:' in line and '(' in line and ')' in line:
        try:
            lib_part = line.split('.pretty:', 1)
            library = lib_part[0].strip()
            fp_info = lib_part[1].strip()
            if '(' in fp_info:
                name_desc = fp_info.split('(', 1)
                name = name_desc[0].strip()
                description = name_desc[1].rstrip(')') if len(name_desc) > 1 else ''
                results.append({{"name": name, "library": library, "description": description}})
        except Exception:
            continue
if len(results) >= max_results:
    results = results[:max_results]
print(json.dumps(results))
"""
    )
    try:
        proc = await asyncio.to_thread(kicad_session.exec_python, script, timeout=120)
    except subprocess.TimeoutExpired as exc:
        return json.dumps({"error": "footprint search timeout", "details": str(exc)})
    except subprocess.CalledProcessError as exc:
        error_details = {
            "subprocess_stderr": exc.stderr.strip(),
            "subprocess_stdout": exc.stdout.strip() if hasattr(exc, "stdout") else "",
            "return_code": exc.returncode,
        }
        return json.dumps({"error": "subprocess failed", "details": error_details})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps(
            {
                "error": "unexpected error",
                "details": str(exc),
                "type": type(exc).__name__,
            }
        )
    return proc.stdout.strip()


@function_tool
async def extract_pin_details(library: str, part_name: str) -> str:
    """Return pin details using skidl.show()."""
    script = textwrap.dedent(f"""
import json, io, contextlib
from skidl import *
set_default_tool(KICAD5)
buf = io.StringIO()
try:
    with contextlib.redirect_stdout(buf):
        show({library!r}, {part_name!r})
except Exception as exc:
    print(json.dumps({{"error": str(exc)}}))
    raise SystemExit()
text = buf.getvalue().splitlines()
pins = []
for line in text:
    line = line.strip()
    if line.startswith("Pin "):
        parts = line.split("/")
        if len(parts) >= 4:
            pins.append({{"number": parts[1], "name": parts[2], "function": parts[3]}})
print(json.dumps(pins))
""")
    try:
        proc = await asyncio.to_thread(kicad_session.exec_python, script, timeout=120)
    except subprocess.TimeoutExpired as exc:
        return json.dumps({"error": "pin extract timeout", "details": str(exc)})
    except subprocess.CalledProcessError as exc:
        return json.dumps({"error": "subprocess failed", "details": exc.stderr.strip()})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({"error": str(exc)})
    return proc.stdout.strip()


def create_mcp_documentation_server() -> MCPServerSse:
    """Create MCP server for SKiDL documentation.

    Returns:
        MCPServerSse configured for the ``skidl_docs`` server.
    """
    url = f"{settings.mcp_url}/sse"
    timeout = 15.0 if os.getenv("DOCKER_ENV") else 10.0
    return MCPServerSse(
        name="skidl_docs",
        params={
            "url": url,
            "timeout": timeout,
            "sse_read_timeout": timeout * 2,
        },
        cache_tools_list=True,
        client_session_timeout_seconds=timeout,
    )


def create_mcp_validation_server() -> MCPServerSse:
    """Create MCP server for hallucination validation.

    Returns:
        MCPServerSse configured for the ``skidl_validation`` server.
    """
    url = f"{settings.mcp_url}/sse"
    timeout = 15.0 if os.getenv("DOCKER_ENV") else 10.0
    return MCPServerSse(
        name="skidl_validation",
        params={
            "url": url,
            "timeout": timeout,
            "sse_read_timeout": timeout * 2,
        },
        cache_tools_list=True,
        client_session_timeout_seconds=timeout,
    )


async def run_erc(script_path: str) -> str:
    """Run a SKiDL script and perform ERC inside Docker.

    Args:
        script_path: Path to the SKiDL script.

    Returns:
        JSON string with ``success`` flag, ``erc_passed`` status, stdout, and stderr.

    Example:
        >>> await run_erc("/tmp/test.py")
        '{"success": true, "erc_passed": true, "stdout": "", "stderr": ""}'
    """

    wrapper = textwrap.dedent(
        """
        import json, runpy, io, contextlib
        from skidl import *
        set_default_tool(KICAD5)
        out = io.StringIO()
        err = io.StringIO()
        success = True
        erc_passed = False
        try:
            with contextlib.redirect_stdout(out), contextlib.redirect_stderr(err):
                runpy.run_path('/tmp/script.py', run_name='__main__')
                result = ERC()
                erc_passed = not bool(result)
        except Exception as exc:
            success = False
            err.write(str(exc))
        print(json.dumps({'success': success, 'erc_passed': erc_passed, 'stdout': out.getvalue(), 'stderr': err.getvalue()}))
        """
    )
    try:
        proc = await asyncio.to_thread(kicad_session.exec_erc, script_path, wrapper)
    except subprocess.TimeoutExpired as exc:
        return json.dumps(
            {"success": False, "erc_passed": False, "stdout": "", "stderr": str(exc)}
        )
    except subprocess.CalledProcessError as exc:
        return json.dumps(
            {
                "success": False,
                "erc_passed": False,
                "stdout": exc.stdout.strip(),
                "stderr": exc.stderr.strip(),
            }
        )
    except Exception as exc:  # pragma: no cover
        return json.dumps(
            {"success": False, "erc_passed": False, "stdout": "", "stderr": str(exc)}
        )

    return proc.stdout.strip()


run_erc_tool = function_tool(run_erc)
