"""
    )
Tools for the Circuitron agents.
Contains calculation tools and other utilities that agents can use.
"""

from agents import function_tool
from agents.tool import HostedMCPTool, Tool
import asyncio
import subprocess
import textwrap
import json
import os
from typing import cast
from openai.types.responses.tool_param import Mcp
from .models import CalcResult
from .config import settings
from .docker_session import DockerSession


kicad_session = DockerSession(settings.kicad_image, "circuitron-kicad")


@function_tool
async def execute_calculation(
    calculation_id: str,
    description: str,
    code: str,
) -> CalcResult:
    """
    Execute pure-Python maths code *generated by the LLM* in an isolated Docker container.

    Args:
        calculation_id: Correlates this request to its tool response.
        description: What this calculation is intended to compute.
        code: Python source (generated by the LLM) that prints the final value.
    Returns:
        CalcResult with stdout, stderr, and success flag.
    """
    safe_code = textwrap.dedent(code)
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "128m",
        "--pids-limit",
        "64",
        settings.calculation_image,
        "python",
        "-c",
        safe_code,
    ]
    try:
        proc = await asyncio.to_thread(
            subprocess.run,
            docker_cmd,
            capture_output=True,
            text=True,
            timeout=15,
            check=True,
        )
    except subprocess.TimeoutExpired as exc:
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))
    except subprocess.CalledProcessError as exc:
        return CalcResult(
            calculation_id=calculation_id,
            success=False,
            stdout=exc.stdout.strip(),
            stderr=exc.stderr.strip(),
        )
    except Exception as exc:  # pragma: no cover - unexpected errors
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))

    return CalcResult(
        calculation_id=calculation_id,
        success=True,
        stdout=proc.stdout.strip(),
        stderr=proc.stderr.strip(),
    )


@function_tool
async def search_kicad_libraries(query: str) -> str:
    """Search KiCad libraries using skidl.search."""
    script = textwrap.dedent(f"""
import json
from skidl import *
set_default_tool(KICAD5)
parts = search({query!r})
results = []
if parts:
    for p in parts:
        results.append({{"name": p.name, "library": getattr(p, "lib", ""), "footprint": getattr(p, "footprint", None), "description": getattr(p, "description", None)}})
print(json.dumps(results))
""")
    try:
        proc = await asyncio.to_thread(
            kicad_session.exec_python, script, timeout=120
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({"error": "search timeout", "details": str(exc)})
    except subprocess.CalledProcessError as exc:
        return json.dumps({"error": "subprocess failed", "details": exc.stderr.strip()})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({"error": str(exc)})
    return proc.stdout.strip()


@function_tool
async def search_kicad_footprints(query: str) -> str:
    """Search KiCad footprint libraries using skidl.search_footprints."""
    script = textwrap.dedent(f"""
import json
from skidl import *
set_default_tool(KICAD5)
footprints = search_footprints({query!r})
results = []
if footprints:
    for fp in footprints:
        results.append({{"name": fp.name, "library": getattr(fp, "lib", ""), "description": getattr(fp, "description", None)}})
print(json.dumps(results))
""")
    try:
        proc = await asyncio.to_thread(
            kicad_session.exec_python, script, timeout=120
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({"error": "footprint search timeout", "details": str(exc)})
    except subprocess.CalledProcessError as exc:
        return json.dumps({"error": "subprocess failed", "details": exc.stderr.strip()})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({"error": str(exc)})
    return proc.stdout.strip()


@function_tool
async def extract_pin_details(library: str, part_name: str) -> str:
    """Return pin details using skidl.show()."""
    script = textwrap.dedent(f"""
import json, io, contextlib
from skidl import *
set_default_tool(KICAD5)
buf = io.StringIO()
try:
    with contextlib.redirect_stdout(buf):
        show({library!r}, {part_name!r})
except Exception as exc:
    print(json.dumps({{"error": str(exc)}}))
    raise SystemExit()
text = buf.getvalue().splitlines()
pins = []
for line in text:
    line = line.strip()
    if line.startswith("Pin "):
        parts = line.split("/")
        if len(parts) >= 4:
            pins.append({{"number": parts[1], "name": parts[2], "function": parts[3]}})
print(json.dumps(pins))
"""
    )
    try:
        proc = await asyncio.to_thread(
            kicad_session.exec_python, script, timeout=120
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({"error": "pin extract timeout", "details": str(exc)})
    except subprocess.CalledProcessError as exc:
        return json.dumps({"error": "subprocess failed", "details": exc.stderr.strip()})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({"error": str(exc)})
    return proc.stdout.strip()


def create_mcp_tool(server_label: str) -> HostedMCPTool:
    """Return a HostedMCPTool configured for the given server label.

    Args:
        server_label: The target label of the MCP server.

    Returns:
        HostedMCPTool configured with the appropriate server URL.
    """
    server_url = os.getenv("MCP_URL", settings.mcp_url)
    tool_data: dict[str, object] = {
        "type": "mcp",
        "server_label": server_label,
        "server_url": server_url,
        "require_approval": "never",
    }
    return HostedMCPTool(tool_config=cast(Mcp, tool_data))


def create_mcp_documentation_tools() -> list[Tool]:
    """Create MCP tools for documentation lookup."""
    return [create_mcp_tool("skidl_docs")]


def create_mcp_validation_tools() -> list[Tool]:
    """Create MCP tool for hallucination checks."""
    return [create_mcp_tool("skidl_validation")]


async def run_erc(script_path: str) -> str:
    """Run a SKiDL script and perform ERC inside Docker.

    Args:
        script_path: Path to the SKiDL script.

    Returns:
        JSON string with ``success`` flag, ``erc_passed`` status, stdout, and stderr.

    Example:
        >>> await run_erc("/tmp/test.py")
        '{"success": true, "erc_passed": true, "stdout": "", "stderr": ""}'
    """

    wrapper = textwrap.dedent(
        """
        import json, runpy, io, contextlib
        from skidl import *
        set_default_tool(KICAD5)
        out = io.StringIO()
        err = io.StringIO()
        success = True
        erc_passed = False
        try:
            with contextlib.redirect_stdout(out), contextlib.redirect_stderr(err):
                runpy.run_path('/tmp/script.py', run_name='__main__')
                result = ERC()
                erc_passed = not bool(result)
        except Exception as exc:
            success = False
            err.write(str(exc))
        print(json.dumps({'success': success, 'erc_passed': erc_passed, 'stdout': out.getvalue(), 'stderr': err.getvalue()}))
        """
    )
    try:
        proc = await asyncio.to_thread(
            kicad_session.exec_erc, script_path, wrapper
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({'success': False, 'erc_passed': False, 'stdout': '', 'stderr': str(exc)})
    except subprocess.CalledProcessError as exc:
        return json.dumps({'success': False, 'erc_passed': False, 'stdout': exc.stdout.strip(), 'stderr': exc.stderr.strip()})
    except Exception as exc:  # pragma: no cover
        return json.dumps({'success': False, 'erc_passed': False, 'stdout': '', 'stderr': str(exc)})

    return proc.stdout.strip()


run_erc_tool = function_tool(run_erc)
