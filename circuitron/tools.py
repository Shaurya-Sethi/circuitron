"""
Tools for the Circuitron agents.
Contains calculation tools and other utilities that agents can use.
"""

from agents import function_tool
from agents.tool import HostedMCPTool
import subprocess
import textwrap
import json
import os
from .models import CalcResult
from .config import settings


@function_tool
async def execute_calculation(
    calculation_id: str,
    description: str,
    code: str,
) -> CalcResult:
    """
    Execute pure-Python maths code *generated by the LLM* in an isolated Docker container.

    Args:
        calculation_id: Correlates this request to its tool response.
        description: What this calculation is intended to compute.
        code: Python source (generated by the LLM) that prints the final value.
    Returns:
        CalcResult with stdout, stderr, and success flag.
    """
    safe_code = textwrap.dedent(code)
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "128m",
        "--pids-limit",
        "64",
        settings.calculation_image,
        "python",
        "-c",
        safe_code,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=15, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))
    except subprocess.CalledProcessError as exc:
        return CalcResult(
            calculation_id=calculation_id,
            success=False,
            stdout=exc.stdout.strip(),
            stderr=exc.stderr.strip(),
        )
    except Exception as exc:  # pragma: no cover - unexpected errors
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))

    return CalcResult(
        calculation_id=calculation_id,
        success=True,
        stdout=proc.stdout.strip(),
        stderr=proc.stderr.strip(),
    )


@function_tool
async def search_kicad_libraries(query: str) -> str:
    """Search KiCad libraries using skidl.search."""
    script = textwrap.dedent(f"""
import json, skidl
parts = skidl.search({query!r})
results = []
if parts:
    for p in parts:
        results.append({{"name": p.name, "library": getattr(p, "lib", ""), "footprint": getattr(p, "footprint", None), "description": getattr(p, "description", None)}})
print(json.dumps(results))
""")
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "512m",
        "--pids-limit",
        "256",
        settings.kicad_image,
        "python",
        "-c",
        script,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=30, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({{"error": "search timeout", "details": str(exc)}})
    except subprocess.CalledProcessError as exc:
        return json.dumps({{"error": "subprocess failed", "details": exc.stderr.strip()}})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({{"error": str(exc)}})
    return proc.stdout.strip()


@function_tool
async def search_kicad_footprints(query: str) -> str:
    """Search KiCad footprint libraries using skidl.search_footprints."""
    script = textwrap.dedent(f"""
import json, skidl
footprints = skidl.search_footprints({query!r})
results = []
if footprints:
    for fp in footprints:
        results.append({{"name": fp.name, "library": getattr(fp, "lib", ""), "description": getattr(fp, "description", None)}})
print(json.dumps(results))
""")
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "512m",
        "--pids-limit",
        "256",
        settings.kicad_image,
        "python",
        "-c",
        script,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=30, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({{"error": "footprint search timeout", "details": str(exc)}})
    except subprocess.CalledProcessError as exc:
        return json.dumps({{"error": "subprocess failed", "details": exc.stderr.strip()}})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({{"error": str(exc)}})
    return proc.stdout.strip()


@function_tool
async def extract_pin_details(library: str, part_name: str) -> str:
    """Return pin details using skidl.show()."""
    script = textwrap.dedent(f"""
import json, io, contextlib, skidl
buf = io.StringIO()
try:
    with contextlib.redirect_stdout(buf):
        skidl.show({library!r}, {part_name!r})
except Exception as exc:
    print(json.dumps({{"error": str(exc)}}))
    raise SystemExit()
text = buf.getvalue().splitlines()
pins = []
for line in text:
    line = line.strip()
    if line.startswith("Pin "):
        parts = line.split("/")
        if len(parts) >= 4:
            pins.append({{"number": parts[1], "name": parts[2], "function": parts[3]}})
print(json.dumps(pins))
""")
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "512m",
        "--pids-limit",
        "256",
        settings.kicad_image,
        "python",
        "-c",
        script,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=30, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({{"error": "pin extract timeout", "details": str(exc)}})
    except subprocess.CalledProcessError as exc:
        return json.dumps({{"error": "subprocess failed", "details": exc.stderr.strip()}})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({{"error": str(exc)}})
    return proc.stdout.strip()


def create_mcp_tool(server_label: str) -> HostedMCPTool:
    """Return a HostedMCPTool configured for the given server label.

    Args:
        server_label: The target label of the MCP server.

    Returns:
        HostedMCPTool configured with the appropriate server URL.
    """
    server_url = os.getenv("MCP_URL", settings.mcp_url)
    return HostedMCPTool(
        tool_config={
            "type": "mcp",
            "server_label": server_label,
            "server_url": server_url,
            "require_approval": "never",
        }
    )


def create_mcp_documentation_tools() -> list[HostedMCPTool]:
    """Create MCP tools for documentation lookup."""
    return [create_mcp_tool("skidl_docs")]


def create_mcp_validation_tools() -> list[HostedMCPTool]:
    """Create MCP tool for hallucination checks."""
    return [create_mcp_tool("skidl_validation")]


@function_tool
async def run_erc(script_path: str) -> str:
    """Run a SKiDL script and perform ERC inside Docker."""

    wrapper = textwrap.dedent(
        """
        import json, runpy, io, contextlib, skidl
        out = io.StringIO()
        err = io.StringIO()
        success = True
        erc_passed = False
        try:
            with contextlib.redirect_stdout(out), contextlib.redirect_stderr(err):
                runpy.run_path('/tmp/script.py', run_name='__main__')
                result = skidl.ERC()
                erc_passed = not bool(result)
        except Exception as exc:
            success = False
            err.write(str(exc))
        print(json.dumps({'success': success, 'erc_passed': erc_passed, 'stdout': out.getvalue(), 'stderr': err.getvalue()}))
        """
    )
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "512m",
        "--pids-limit",
        "256",
        "-v",
        f"{script_path}:/tmp/script.py:ro",
        settings.kicad_image,
        "python",
        "-c",
        wrapper,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=60, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({"success": False, "erc_passed": False, "stdout": "", "stderr": str(exc)})
    except subprocess.CalledProcessError as exc:
        return json.dumps({"success": False, "erc_passed": False, "stdout": exc.stdout.strip(), "stderr": exc.stderr.strip()})
    except Exception as exc:  # pragma: no cover
        return json.dumps({"success": False, "erc_passed": False, "stdout": "", "stderr": str(exc)})

    return proc.stdout.strip()

