"""
Tools for the Circuitron agents.
Contains calculation tools and other utilities that agents can use.
"""

from agents import function_tool
import subprocess
import textwrap
import json
from .models import CalcResult
from .config import settings


@function_tool
async def execute_calculation(
    calculation_id: str,
    description: str,
    code: str,
) -> CalcResult:
    """
    Execute pure-Python maths code *generated by the LLM* in an isolated Docker container.

    Args:
        calculation_id: Correlates this request to its tool response.
        description: What this calculation is intended to compute.
        code: Python source (generated by the LLM) that prints the final value.
    Returns:
        CalcResult with stdout, stderr, and success flag.
    """
    safe_code = textwrap.dedent(code)
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "128m",
        "--pids-limit",
        "64",
        settings.calculation_image,
        "python",
        "-c",
        safe_code,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=15, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))
    except subprocess.CalledProcessError as exc:
        return CalcResult(
            calculation_id=calculation_id,
            success=False,
            stdout=exc.stdout.strip(),
            stderr=exc.stderr.strip(),
        )
    except Exception as exc:  # pragma: no cover - unexpected errors
        return CalcResult(calculation_id=calculation_id, success=False, stderr=str(exc))

    return CalcResult(
        calculation_id=calculation_id,
        success=True,
        stdout=proc.stdout.strip(),
        stderr=proc.stderr.strip(),
    )


@function_tool
async def search_kicad_libraries(query: str) -> str:
    """Search KiCad libraries using skidl.search."""
    script = textwrap.dedent(f"""
import json, skidl
parts = skidl.search({query!r})
results = []
if parts:
    for p in parts:
        results.append({{"name": p.name, "library": getattr(p, "lib", ""), "footprint": getattr(p, "footprint", None), "description": getattr(p, "description", None)}})
print(json.dumps(results))
""")
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "512m",
        "--pids-limit",
        "256",
        settings.kicad_image,
        "python",
        "-c",
        script,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=30, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({{"error": "search timeout", "details": str(exc)}})
    except subprocess.CalledProcessError as exc:
        return json.dumps({{"error": "subprocess failed", "details": exc.stderr.strip()}})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({{"error": str(exc)}})
    return proc.stdout.strip()


@function_tool
async def search_kicad_footprints(query: str) -> str:
    """Search KiCad footprint libraries using skidl.search_footprints."""
    script = textwrap.dedent(f"""
import json, skidl
footprints = skidl.search_footprints({query!r})
results = []
if footprints:
    for fp in footprints:
        results.append({{"name": fp.name, "library": getattr(fp, "lib", ""), "description": getattr(fp, "description", None)}})
print(json.dumps(results))
""")
    docker_cmd = [
        "docker",
        "run",
        "--rm",
        "--network",
        "none",
        "--memory",
        "512m",
        "--pids-limit",
        "256",
        settings.kicad_image,
        "python",
        "-c",
        script,
    ]
    try:
        proc = subprocess.run(
            docker_cmd, capture_output=True, text=True, timeout=30, check=True
        )
    except subprocess.TimeoutExpired as exc:
        return json.dumps({{"error": "footprint search timeout", "details": str(exc)}})
    except subprocess.CalledProcessError as exc:
        return json.dumps({{"error": "subprocess failed", "details": exc.stderr.strip()}})
    except Exception as exc:  # pragma: no cover - unexpected errors
        return json.dumps({{"error": str(exc)}})
    return proc.stdout.strip()
